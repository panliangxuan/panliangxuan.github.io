<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代谢组学</title>
      <link href="/posts/1315.html"/>
      <url>/posts/1315.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="【代谢组学】-数据分析"><a href="#【代谢组学】-数据分析" class="headerlink" title="【代谢组学】  数据分析"></a>【代谢组学】  数据分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="代谢物"><a href="#代谢物" class="headerlink" title="代谢物"></a>代谢物</h4><p>所有分子量小于1500Da的小分子物质，包括糖类、核苷、有机酸、酮类化合物、多肽、氨基酸、有机胺类、醛类化合物、脂质、萜类、类固醇、生物碱、小分子药物等等。</p><h4 id="代谢组"><a href="#代谢组" class="headerlink" title="代谢组"></a>代谢组</h4><p>一个细胞、组织、器官中所有代谢物的集合。</p><h4 id="代谢组学"><a href="#代谢组学" class="headerlink" title="代谢组学"></a>代谢组学</h4><p>利用高通量的技术来鉴定和定量一个细胞、组织或器官中所有小分子或代谢物的生命科学研究。</p><h2 id="代谢组学分类与应用"><a href="#代谢组学分类与应用" class="headerlink" title="代谢组学分类与应用"></a>代谢组学分类与应用</h2><table><thead><tr><th align="center"></th><th align="center">非靶向代谢组学</th><th align="center">靶向代谢组学</th></tr></thead><tbody><tr><td align="center">研究目的</td><td align="center">无偏向性的对所有小分子代谢物同时进行检测分析</td><td align="center">对指定列表的代谢产物的分子，特别针对一种或几种途径的代谢产物</td></tr><tr><td align="center">优点</td><td align="center">无偏向性，高通量，样本无序特出处理且一次进样分析</td><td align="center">灵敏度高，完全定量，可得到样本中代谢物的浓度</td></tr><tr><td align="center">缺点</td><td align="center">需要进行复杂的生物信息学分析；只能获得半定量的结果</td><td align="center">需要购买标准品，进行分析方法的开发、验证，研究成本高</td></tr><tr><td align="center">分析平台</td><td align="center">NMR、LC-MS、GC-MS等</td><td align="center">HPLC、GC、LC-MS、GC-MS等</td></tr></tbody></table><table><thead><tr><th align="center">分析技术</th><th>灵敏度mol</th><th align="center">优势</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">核磁共振NMR</td><td>10-6</td><td align="center">无创检测，样品需求量大；特异性高、分辨率高，能够对代谢物同时完成定性和定量分析</td><td align="center">动态范围有限，灵敏度较低，硬件投资较大</td></tr><tr><td align="center">液质联用LC-MS</td><td>10-15</td><td align="center">灵敏度、分辨率高，可以分析不稳定、不易衍生化、难挥发和分子量较大的代谢物</td><td align="center">数据库不健全，可鉴定的化合物有限</td></tr><tr><td align="center">气质联用GC-MS</td><td>10-12</td><td align="center">分辨率、选择性好，数据库较多</td><td align="center">样品处理过程较为繁琐，难挥发性物种或半挥发性物种需要衍生化后才能进行分析</td></tr></tbody></table><p>代谢组学应用：</p><ul><li>遗传疾病分析</li><li>营养成分分析</li><li>临床样品分析</li><li>耐药性分析</li><li>移植监测</li><li>毒理学测试</li><li>发酵过程检测</li><li>药物分型</li><li>水质分析</li><li>石油化学品分析</li></ul><h2 id="代谢组学研究意义与优势"><a href="#代谢组学研究意义与优势" class="headerlink" title="代谢组学研究意义与优势"></a>代谢组学研究意义与优势</h2><ul><li>代谢组的时间响应在所有组学中最快。</li><li>代谢组的结果易于理解，容易与表型和功能结合。</li></ul><h2 id="代谢组学分析流程"><a href="#代谢组学分析流程" class="headerlink" title="代谢组学分析流程"></a>代谢组学分析流程</h2><ol><li>样本收集</li><li>数据采集（NMR&#x2F;LC-MS&#x2F;GC-MS获取谱图数据）</li><li>谱图——峰表（谱图处理得到特征矩阵）</li><li>代谢物定性（谱图数据库与数据集峰位置、相关模式、相对强度等特征相匹配）</li><li>差异离子筛选（单变量分析、非监督&#x2F;监督多变量分析、多元分析、分类模型、候选标志物）</li><li>功能分析（Pathway分析、富集分析、相关性网络分析（高斯模型和拓扑结构））</li></ol><h2 id="非靶向代谢组实验设计"><a href="#非靶向代谢组实验设计" class="headerlink" title="非靶向代谢组实验设计"></a>非靶向代谢组实验设计</h2><ol><li>代谢物提取，一般要求每组至少10个样；</li><li>在所有提取好的样本中取等量混合作为QC；</li><li>QC样本与实验样本穿插上机，开始十个QC，结尾三个QC，中间每十个样本穿插一个QC样本。</li></ol><h2 id="数据分析流程"><a href="#数据分析流程" class="headerlink" title="数据分析流程"></a>数据分析流程</h2><p>一般有如下几点：</p><ol><li>数据预处理。如缺失值过滤填充、数据归一化等。</li><li>数据质控。包括CV分布、QC等。</li><li>统计分析。包括单变量、多变量等。</li><li>功能分析。包括Pathway、网络分析、Biomarker筛选等。</li></ol><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><h4 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h4><ol><li><h5 id="缺失原因"><a href="#缺失原因" class="headerlink" title="缺失原因"></a>缺失原因</h5><ul><li>信号很低检测不到；</li><li>检测错误，如离子抑制或者仪器性能不稳定；</li><li>提峰的算法限制，不能从背景中将低的信号提取出来；</li><li>解卷积时不能将重叠的峰全部解析出来。</li></ul></li><li><h5 id="缺失值过滤"><a href="#缺失值过滤" class="headerlink" title="缺失值过滤"></a>缺失值过滤</h5><ul><li><p>QC样本中缺失超过50%的去除；</p></li><li><p>样本中缺失值超过80%的去除。</p><p><img src="https://upload-images.jianshu.io/upload_images/7698829-c2b7e0ea378e2172.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p></li></ul></li><li><h5 id="缺失值填充"><a href="#缺失值填充" class="headerlink" title="缺失值填充"></a>缺失值填充</h5><ul><li><p>最小值填充</p></li><li><p>平均值&#x2F;中值填充</p></li><li><p>KNN（ K-Neares Neighbor）填充</p></li><li><p>BPCA（Bayesian PCA）填充</p></li><li><p>PPCA（Probabilistic PCA）填充</p></li><li><p>Singular Value Decomposition (SVD) 填充</p></li><li><p>RF（RandomForest）填充</p><p><strong>一般推荐KNN，RF填充</strong></p></li></ul></li></ol><h4 id="噪音信号处理"><a href="#噪音信号处理" class="headerlink" title="噪音信号处理"></a>噪音信号处理</h4><p>一般是低质量的离子。</p><h5 id="低质量离子的确定："><a href="#低质量离子的确定：" class="headerlink" title="低质量离子的确定："></a>低质量离子的确定：</h5><ul><li>计算某个离子在QC样本中的CV（标准差&#x2F;均值， 也称变异系数）；其值越小，说明偏差越小；</li></ul><h5 id="判断标准："><a href="#判断标准：" class="headerlink" title="判断标准："></a>判断标准：</h5><ul><li>对单个离子峰而言，CV&lt;0.3，则该离子峰合格，否则去除；</li><li>对于整体数据而言，CV&lt;0.3，峰所占比例&gt;60%，则整体数据合格；</li></ul><h4 id="样本归一化"><a href="#样本归一化" class="headerlink" title="样本归一化"></a>样本归一化</h4><p>目的是为了提高样本间的可比性。</p><p>样本间有差异性，如不同人的尿液浓度不同，不能直接拿来比较。</p><p>可在采集前归一化，如肌酸酐归一化；也可在采集后归一化，如sum，pqn，quantile等。</p><p>对于数据分析而言，通常是后者，如总和归一化（sum）。</p><h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><p>下游的分析一般要求数据为正态分布或者高斯分布；</p><p>所以数据通常要进行Log转化或power转化，这两者都能够将极大值的抑制效应消除，</p><p>并且能够调整数据的分布，如下图；</p><p><img src="https://upload-images.jianshu.io/upload_images/7698829-8a0957287ed6136c.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><h3 id="数据质控"><a href="#数据质控" class="headerlink" title="数据质控"></a>数据质控</h3><h4 id="QC样本的TIC重叠情况"><a href="#QC样本的TIC重叠情况" class="headerlink" title="QC样本的TIC重叠情况"></a>QC样本的TIC重叠情况</h4><p><img src="https://upload-images.jianshu.io/upload_images/7698829-e1e55a56e5e7bcfb.png" alt="img"></p><p>上图分别是阴离子和阳离子模式下QC样本的TIC重叠情况。</p><p>一般认为：</p><p>所有的QC样本峰重叠良好；</p><p>峰强度波动差别不大；</p><h4 id="QC样本中CV-lt-30-的峰所占比例"><a href="#QC样本中CV-lt-30-的峰所占比例" class="headerlink" title="QC样本中CV&lt;30%的峰所占比例"></a>QC样本中CV&lt;30%的峰所占比例</h4><p><img src="https://upload-images.jianshu.io/upload_images/7698829-32583752da4b2230.png" alt="img"></p><h4 id="PCA中QC样本的聚集程度"><a href="#PCA中QC样本的聚集程度" class="headerlink" title="PCA中QC样本的聚集程度"></a>PCA中QC样本的聚集程度</h4><p><img src="https://upload-images.jianshu.io/upload_images/7698829-4edd875c2206cacf.png" alt="img"></p><h4 id="QC样本的相关性"><a href="#QC样本的相关性" class="headerlink" title="QC样本的相关性"></a>QC样本的相关性</h4><p><img src="https://upload-images.jianshu.io/upload_images/7698829-25ec14d80eff83b5.png" alt="img"></p><p>上图分别为归一化前和归一化后的数据。</p><h3 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h3><h4 id="单变量分析"><a href="#单变量分析" class="headerlink" title="单变量分析"></a>单变量分析</h4><p>一次只分析一个变量，即一个m&#x2F;z，</p><p>考察不同组别不同样本的这个m&#x2F;z表达有无差异？</p><p>常见的方法有倍数分析，t检验，秩和检验，方差分析等。</p><h4 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h4><p>核心思想就是根据具体的指标(变量)对所研究的样品进行分类；</p><p>聚类分析需要设定一个方法来衡量样本间的相似性或者不相似性（常用欧式距离，相关性系数等）；</p><p>常见聚类的方法：系统聚类（层次聚类）、K-均值聚类等。</p><p>K-均值首先要估计出将要分出几个类，然后将全部的基因按照相似性的距离，归入这几类中。</p><p>K– means计算量要小得多，效率比层次聚类要高。</p><p>无论哪种分类方法，最终要分成多少类，并不是完全由方法本身来决定，研究者应结合具体问题而定。</p><p>聚类分析是一种探索性的数据分析方法。相同的数据采用不同的分类方法，也会的得到不同的分类结果。</p><p>分类的结果没有对错之分，只是分类标准不同。</p><p>使用聚类方法时，首先要明确分类的目的，再考虑选择哪些变量(或数据)参与分类，最后才需要考虑方法的选择。</p><h4 id="多变量分析"><a href="#多变量分析" class="headerlink" title="多变量分析"></a>多变量分析</h4><ol><li><h5 id="PCA分析"><a href="#PCA分析" class="headerlink" title="PCA分析"></a>PCA分析</h5><p>以下分别是得分图（样本在新的坐标系中的位置）和载荷图(loading图，原变量与主成分间的夹角)</p><p><img src="https://upload-images.jianshu.io/upload_images/7698829-7d007680c4f8486a.png" alt="img"></p><p>PCA结果如何分析？</p><ul><li>组内差异</li><li>组间差异</li><li>异常样本</li><li>PC1与PC2得分</li></ul></li><li><h5 id="偏最小二乘法"><a href="#偏最小二乘法" class="headerlink" title="偏最小二乘法"></a>偏最小二乘法</h5><p>PLSDA的图和PCA类似。只是一种监督学习的方法，事先给样本分类，最后看能否将不同组分开。</p><p>用R2和Q2进行模型评价。</p><p>R2是相关性系数，表示这个模型的拟合效果，是一个定量的测量（范围0-1），意味着所建立的模型能在多大程度上代表真实的数据；</p><p>一般当R2在0.7-0.8表示模型解释能力较好，较差的模型的R2往往为0.2-0.3</p><p>Q2表示PLS-DA模型的预测能力；</p><p>一般Q2大于0.5表示预测能力较好，并且R2与Q2的值应该比较接近。</p><p>使用permutation test模型进行过拟合检验。</p><p>VIP ( Variable Importance in Projection)变量重要性投影</p><p>每一个m&#x2F;z都有VIP值，表示这个m&#x2F;z在某一个主成分上的投影，即重要程度；</p><p>一般我们使用第一、第二主成分的VIP来表示这个m&#x2F;z对模型分型的贡献程度，VIP&gt;&#x3D;1被认为是具有显著贡献的。</p></li></ol><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3>]]></content>
      
      
      <categories>
          
          <category> 生物信息分析 </category>
          
          <category> 代谢组学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物信息分析 </tag>
            
            <tag> 代谢组学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/posts/1314.html"/>
      <url>/posts/1314.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><h2 id="正态分布检验"><a href="#正态分布检验" class="headerlink" title="正态分布检验"></a>正态分布检验</h2><h3 id="T-test"><a href="#T-test" class="headerlink" title="T-test"></a>T-test</h3><h4 id="单样本均值检验（One-sample-t-test）"><a href="#单样本均值检验（One-sample-t-test）" class="headerlink" title="单样本均值检验（One-sample t-test）"></a>单样本均值检验（One-sample t-test）</h4><p>用于检验 总体方差未知、正态数据或近似正态的 单样本的均值 是否与 已知的总体均值相等</p><h4 id="两独立样本均值检验（Independent-two-sample-t-test）"><a href="#两独立样本均值检验（Independent-two-sample-t-test）" class="headerlink" title="两独立样本均值检验（Independent two-sample t-test）"></a>两独立样本均值检验（Independent two-sample t-test）</h4><p>用于检验 两对独立的 正态数据或近似正态的 样本的均值 是否相等，这里可根据总体方差是否相等分类讨论</p><h4 id="配对样本均值检验（Dependent-t-test-for-paired-samples）"><a href="#配对样本均值检验（Dependent-t-test-for-paired-samples）" class="headerlink" title="配对样本均值检验（Dependent t-test for paired samples）"></a>配对样本均值检验（Dependent t-test for paired samples）</h4><p>用于检验 一对配对样本的均值的差 是否等于某一个值</p><h4 id="回归系数的显著性检验（t-test-for-regression-coefficient-significance）"><a href="#回归系数的显著性检验（t-test-for-regression-coefficient-significance）" class="headerlink" title="回归系数的显著性检验（t-test for regression coefficient significance）"></a>回归系数的显著性检验（t-test for regression coefficient significance）</h4><p>用于检验 回归模型的解释变量对被解释变量是否有显著影响</p><h3 id="Shapiro–Wilk-test"><a href="#Shapiro–Wilk-test" class="headerlink" title="Shapiro–Wilk test"></a>Shapiro–Wilk test</h3><p>Shapiro–Wilk test是正态性检验最为有效的方法之一，是一种在频率统计中检验正态性的方法，但其测试基础较难理解（不多加叙述）。该方法在每一个样本值都是唯一时的检验效果最好，但若样本中存在几个值重复的情况下该方法便会大打折扣。因此该方法只适用于小样本，推荐样本量为7<del>2000，Origion中允许样本大小为3</del>5000，当样本量超过5000时不再适用。该方法仅适用于正态性检验。</p><h3 id="Kolmogorov–Smirnov-test"><a href="#Kolmogorov–Smirnov-test" class="headerlink" title="Kolmogorov–Smirnov test"></a>Kolmogorov–Smirnov test</h3><p>简称为K-S检验, 是最为常用的正态性检验方法之一，其方法主要是计算出经验分布和理论分布之间的距离，并将其中最大的距离（差异）作为检验统计量。因此K-S检验的优点是不仅可检验正态分布，还可用于检验其他任何分布。但K-S检验需要我们已经事先知道分布总体的均值和方差，即需要指定总体的均值和方差才能进行计算，但在实际情况下很少会事先知道总体的均值和方差，所以难以进行K-S检验。同时也因为仅仅把分布间的最大差异作为统计量，因此相比于其他检验方法其敏感性相对弱一些，因此在GraphPad软件中不推荐使用该方法来进行正态性检验，但实际上在大样本情况下K-S检验还是非常实用的（SAS推荐样本量&gt;2000）。</p><h2 id="方差齐性检验"><a href="#方差齐性检验" class="headerlink" title="方差齐性检验"></a>方差齐性检验</h2><h3 id="方差比"><a href="#方差比" class="headerlink" title="方差比"></a>方差比</h3><p>方差比顾名思义就是两组方差的比，用较大一组的方差除较小一组的方差，最后得到一个F值，然后根据F值的大小来判断两组之间的方差是否相等。F值越大，则认为两组方差越不相等。</p><h3 id="Hartley检验"><a href="#Hartley检验" class="headerlink" title="Hartley检验"></a>Hartley检验</h3><p>Hartley检验与方差比的思想比较类似，差别在于Hartley检验用于多组方差的检验，用多组中最大的方差除最小的方差，得到一个F值，然后通过F值的判断来对方差齐性进行判断。</p><h3 id="Levene检验"><a href="#Levene检验" class="headerlink" title="Levene检验"></a>Levene检验</h3><p>Levene检验是将每个值先转换为为该值与其组内均值的偏离程度，然后再用转换后的偏离程度去做方差分析，即组间方差&#x2F;组内方差。</p>]]></content>
      
      
      <categories>
          
          <category> 生物信息分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生物信息分析 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片名字</title>
      <link href="/posts/123.html"/>
      <url>/posts/123.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://w.wallhaven.cc/full/ln/wallhaven-lnzlo0.jpg" alt="图片名称描述文字"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  torch</span><br><span class="line"><span class="keyword">import</span>  torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span>  torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span>  torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span>    torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">batch_size=<span class="number">200</span></span><br><span class="line">learning_rate=<span class="number">0.01</span></span><br><span class="line">epochs=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                   transform=transforms.Compose([</span><br><span class="line">                       transforms.ToTensor(),</span><br><span class="line">                       transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                   ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">    ])),</span><br><span class="line">    batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">200</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">200</span>, <span class="number">10</span>),</span><br><span class="line">            nn.LeakyReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">net = MLP().to(device)</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=learning_rate)</span><br><span class="line">criteon = nn.CrossEntropyLoss().to(device)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line"></span><br><span class="line">        logits = net(data)</span><br><span class="line">        loss = criteon(logits, target)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># print(w1.grad.norm(), w2.grad.norm())</span></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data = data.view(-<span class="number">1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        data, target = data.to(device), target.cuda()</span><br><span class="line">        logits = net(data)</span><br><span class="line">        test_loss += criteon(logits, target).item()</span><br><span class="line"></span><br><span class="line">        pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        correct += pred.eq(target).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一个博客文章</title>
      <link href="/posts/343230a4.html"/>
      <url>/posts/343230a4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>1826年9月17日，黎曼生于德国北部汉诺威的布雷塞伦茨村，父亲是一个乡村的穷苦牧师。他6岁开始上学，14岁进入大学预科学习，19岁按其父亲的意愿进入哥廷根大学攻读哲学和神学，以便将来继承父志也当一名牧师。由于从小酷爱数学，黎曼在学习哲学和神学的同时也听些数学课。当时的哥廷根大学是世界数学的中心之一，—些著名的数学家如高斯、韦伯、斯特尔都在校执教。黎曼被这里的数学教学和数学研究的气氛所感染，决定放弃神学，专攻数学。</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>1847年，黎曼转到柏林大学学习，成为雅可比、狄利克雷、施泰纳、艾森斯坦的学生。1849年重回哥廷根大学攻读博士学位，成为高斯晚年的学生。</p><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><p>1851年，黎曼获得数学博士学位；1854年被聘为哥廷根大学的编外讲师；1857年晋升为副教授；1859年接替去世的狄利克雷被聘为教授。</p><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p>19世纪数学最独特的创造是复变函数理论的创立，它是18世纪人们对复数及复函数理论研究的延续。1850年以前，柯西、雅可比、高斯、阿贝尔、维尔斯特拉斯已对单值解析函数的理论进行了系统的研究，而对于多值函数仅有柯西和皮瑟有些孤立的结论。</p><h3 id="三级标题-2"><a href="#三级标题-2" class="headerlink" title="三级标题"></a>三级标题</h3><p>1851年，黎曼在高斯的指导下完成题为《单复变函数的一般理论的基础》的博士论文，后来又在《数学杂志》上发表了四篇重要文章，对其博士论文中思想的做了进一步的阐述，一方面总结前人关于单值解析函数的成果，并用新的工具予以处理，同时创立多值解析函数的理论基础，并由此为几个不同方向的进展铺平了道路。</p><h3 id="三级标题-3"><a href="#三级标题-3" class="headerlink" title="三级标题"></a>三级标题</h3><p>柯西、黎曼和维尔斯特拉斯是公认的复变函数论的主要奠基人，而且后来证明在处理复函数理论的方法上黎曼的方法是本质的，柯西和黎曼的思想被融合起来，维尔斯特拉斯的思想可以从柯西—黎曼的观点推导出来。<br>在黎曼对多值函数的处理中，最关键的是他引入了被后人称“黎曼面”的概念。通过黎曼面给多值函数以几何直观，且在黎曼面上表示的多值函数是单值的。他在黎曼面上引入支点、横剖线、定义连通性，开展对函数性质的研究获得一系列成果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
